<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://monikajassova.github.io name=base><title>
            
                Netradičné prístupy k testovaniu
            
        </title><meta content="Netradičné prístupy k testovaniu" property=og:title><meta content="Prehľad zaujímavých prístupov k testovaniu, s ktorými som sa stretla v ostatnej práci." property=og:description><meta content="Prehľad zaujímavých prístupov k testovaniu, s ktorými som sa stretla v ostatnej práci." name=description><link href=https://monikajassova.github.io/icons/favicon.ico rel=icon type=image/png><link href=/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link crossorigin href=https://cdn.jsdelivr.net rel=preconnect><link href=https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/@fontsource/space-grotesk@4.5.8/index.min.css rel=stylesheet><script async data-goatcounter=https://miti.goatcounter.com/count src=https://monikajassova.github.io/js/count.js></script><noscript><img src="https://miti.goatcounter.com//count?p=/blog/netradicne-testovanie/&t=Netradičné prístupy k testovaniu"></noscript><script defer src=https://monikajassova.github.io/js/codeblock.js></script><script defer src=https://monikajassova.github.io/js/toc.js></script><link title="
    Monikin ITinerár
" href=https://monikajassova.github.io/atom.xml rel=alternate type=application/atom+xml><link title="
    Monikin ITinerár
" href=https://monikajassova.github.io/rss.xml rel=alternate type=application/rss+xml><link href=https://monikajassova.github.io/theme/light.css rel=stylesheet><link href=https://monikajassova.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://monikajassova.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://monikajassova.github.io/main.css media=screen rel=stylesheet><link href=https://monikajassova.github.io/custom.css rel=stylesheet><script src="https://monikajassova.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://monikajassova.github.io>Monikin ITinerár</a><div class=socials><a rel="me noopener" class=social href=https://linkedin.com/in/monika-jassova/ target=_blank> <img alt=linkedin src=https://monikajassova.github.io/icons/social/linkedin.svg> </a><a rel="me noopener" class=social href=https://github.com/MonikaJassova/ target=_blank> <img alt=github src=https://monikajassova.github.io/icons/social/github.svg> </a></div></div><div class=right-nav><a href=https://monikajassova.github.io/blog style=margin-right:.5em>/blog</a><a href=https://monikajassova.github.io/projects style=margin-right:.5em>/projekty</a><a href=https://monikajassova.github.io/tags style=margin-right:.5em>/tagy</a><a href=https://monikajassova.github.io/about style=margin-right:.5em>/o mne</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://monikajassova.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Vyhľadávanie</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Hľadať... role=combobox spellcheck=false><button title="Clear Search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>Žiadne výsledky</span><span id=one_result style=display:none>1 výsledok</span><span id=many_results style=display:none>$NUMBER výsledkov</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://monikajassova.github.io/icons/sun.svg> <img alt=Dark id=moon-icon src=https://monikajassova.github.io/icons/moon.svg style=filter:invert()> <img alt=Auto id=auto-icon src=https://monikajassova.github.io/icons/auto.svg style=filter:invert()> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Netradičné prístupy k testovaniu</div><div class=meta>Publikované <time>13.05.2025</time><span class=tags-label> ::</span><span class=tags> <a class=post-tag href=https://monikajassova.github.io/tags/it/>IT</a> <a class=post-tag href=https://monikajassova.github.io/tags/blockchain/>blockchain</a> <a class=post-tag href=https://monikajassova.github.io/tags/testovanie/>testovanie</a> </span></div></div><section class=body><p><em>Prehľad zaujímavých prístupov k testovaniu, s ktorými som sa stretla na blockchainovom projekte (ako kritický vyžadoval vyššiu mieru istoty a na overenie dizajnu základných kameňov sa využívali aj matematické metódy formálnej verifikácie). Tiež prístupy, ktoré vyzerajú byť dobrým kandidátom na zaradenie do arzenálu. Pôjdeme v smere od unit testov až k E2E testom na produkčnom prostredí.</em><h1 id=mutation-testing><a aria-label="Anchor link for: mutation-testing" class=zola-anchor href=#mutation-testing>Mutation testing</a></h1><p>Mutation testing sa používa na otestovanie unit testov, zhodnotenie ich efektívnosti, kvality. Jeho koncept je veľmi jednoduchý a geniálny - mutácia je zavedenie modifikácie zdrojového kódu aplikácie, napr. otočenie aritmetického znamienka, zmena logického operátora, opačná hodnota boolean a pod., po čom sa očakáva, že unit testy by zmenu v programe mali zachytiť a spadnúť. Ak sa tak nestane a "mutant" prežije, unit testy nedostatočne pokrývajú kód testami (aj pri 100% code coverage nám môžu chýbať negatívne testovacie prípady a iné).<br> Je vhodný v situácii, kedy potrebujeme zistiť, ako je na tom s unit testami projekt, na ktorý sme prišli a nepoznáme ho alebo napr. open-source projekty. Mutation testy sa môžu použiť aj na otestovanie efektivity <a href=https://monikajassova.github.io/blog/netradicne-testovanie/#property-based-testing>property-based unit testov</a>.<br> Nevýhodou je, že beh mutation testov trvá dlhšie ako unit testy.<div><iframe allowfullscreen height=315 mozallowfullscreen src=https://www.youtube.com/embed/Vq9eqZzblfg webkitallowfullscreen width=100%></iframe></div><p>Príkladmi konkrétnych frameworkov sú:<ul><li><a rel="noopener external" class=external href=https://stryker-mutator.io/ target=_blank>Stryker Mutator</a> pre JavaScript/TypeScript, Scalu a C#<li><a rel="noopener external" class=external href=https://pitest.org/ target=_blank>Pitest</a> pre Javu a JVM<li><a rel="noopener external" class=external href=https://github.com/sixty-north/cosmic-ray target=_blank>Cosmic Ray</a> pre Python</ul><h1 id=property-based-testing><a aria-label="Anchor link for: property-based-testing" class=zola-anchor href=#property-based-testing>Property-based testing</a></h1><p>Klasické testy, s ktorými sa stretávame, sú založené na konkrétnych príkladoch - pre takýto vstup očakávam takýto výstup. Napr. funkciu na vrátenie true/false, či používateľ je plnoletý na základe veku, viem otestovať niekoľkými príkladmi: pre 17 rokov očakávam false, pre 18 true, pre 0 false, pre 100 true.<br> Property-based testy sú založené na definovaní všeobecných vlastností, ktoré sú platné pre všetky možné hodnoty. Developer zadefinuje, akého typu a z akého rozpätia vstupy majú byť (existujú vstavané generátory pre primitívne dátové typy, príp. developer nakódi vlastný generátor pre typy a triedy, aké potrebuje) a PBT framework vygeneruje veľký počet náhodných hodnôt, ktoré sú otestované, či spĺňajú dané vlastnosti. Vlastnosť môže byť vyjadrená takýmto spôsobom:<pre class=giallo style=color:#cdd6f4;background-color:#1e1e2e><code data-lang=plain><span class=giallo-l><span>  pre hocijaké (x, y, ...)</span></span>
<span class=giallo-l><span>  také, že spĺňa predpoklad(x, y, ...)</span></span>
<span class=giallo-l><span>  výrok (x, y, ...) je pravdivý</span></span></code></pre><p>Príkladmi konkrétnych frameworkov sú:<ul><li><a rel="noopener external" class=external href=https://fast-check.dev/ target=_blank>fast-check</a> pre JS/TS<li><a rel="noopener external" class=external href=https://hypothesis.works/ target=_blank>Hypothesis</a> pre Python<li><a rel="noopener external" class=external href=https://scalacheck.org/ target=_blank>ScalaCheck</a> a <a rel="noopener external" class=external href=https://hedgehogqa.github.io/scala-hedgehog/ target=_blank>Hedgehog</a> pre Scalu<li>ďalšie jazyky nájdete na <a rel="noopener external" class=external href=https://github.com/jmid/pbt-frameworks target=_blank>https://github.com/jmid/pbt-frameworks</a> <ul><li>výhodnou funkcionalitou frameworku je shrinking, ktorý sa pri nájdení výnimky z vlastností postará o zjednodušený minimalizovaný prípad na reprodukciu problému</ul></ul><p>Písanie takýchto testov si vyžaduje zmenu spôsobu myslenia a kreativitu, developer/tester si musí odvodiť univerzálne platné vlastnosti, premýšľať o korektných vstupoch a hlboko porozumieť požiadavkám, ako má funkcionalita fungovať skôr ako pri tradičnom prístupe. PBT sú komplementárne ku klasickým example-based testom - môžu identifikovať hraničné prípady a potenciálne problémy, na ktoré nebolo myslené pri example-based testoch. Taktiež môžu odhaliť neočakávané problémy spojené so špecifickou množinou vstupov alebo mylné predstavy.<br> PBT majú vyššie náklady, ale aj vyššiu hodnotu. Použiť sa dajú aj na vyšších úrovniach nad unit testami. Tipy pre uvažovanie a výber vlastností: <a rel="noopener external" class=external href=https://fsharpforfunandprofit.com/posts/property-based-testing-2/ target=_blank>https://fsharpforfunandprofit.com/posts/property-based-testing-2/</a><p>Stratégie implementácie:<ul><li>začať s example-based, keď tie sú hotové, pridať property-based<li>napísať property-based len pre kľúčové komponenty systému <ul><li>komplikované, ktoré nie úplne chápeme, čo robia<li>kritické pre klienta</ul></ul><p>Viac vo videu:<div><iframe allowfullscreen height=315 mozallowfullscreen src=https://www.youtube.com/embed/gENnmmOjifA webkitallowfullscreen width=100%></iframe></div><p>Prípadom frameworku postaveného na PBT je <a rel="noopener external" class=external href=https://quickstrom.io/ target=_blank>Quickstrom</a> na testovanie webových aplikácií, ktorý k vlastnostiam pridáva lineárnu temporálnu logiku - aplikáciu vieme popísať špecifikáciou, ktorá hovorí, aké prechody stavov sú validné, ktorý stav má nastať po ktorom, aký stav nastane aspoň raz/vždy a pod. V Quickstrome definujeme akcie, ktoré sa dajú v aplikácii vykonať, stavy, v ktorých sa aplikácia môže nachádzať a Quickstrom sa postará o to, aby vygeneroval náhodné sledy akcií a vyhodnotil, či skutočne nadobudnutý sled stavov zodpovedá špecifikácii a aplikácia nespravila niečo neočakávané.<br> Nevýhodou je strmá krivka učenia, skromná dokumentácia, projekt nie je ešte dostatočne zrelý - limitovaná podpora dynamického obsahu a ťažkosti s načasovaním. Interný proof of concept taktiež odhalil nespoľahlivé alebo neúčinné selektory pre identifikáciu elementov, že defaultné správanie vyhodnotenia viditeľnosti a aktívnosti elementov pre vykonanie akcie nie vždy vyhovovalo a boli potrebné rôzne hacky a explicitné predpoklady, kedy môže byť akcia vykonaná. Neponúka ani schopnosť simultánne pracovať s viacerými stránkami alebo otestovať viac súborov cez príkaz <code>check</code>.<p>Iným nástrojom, ktorý využíva PBT, je <a rel="noopener external" class=external href=https://schemathesis.io/ target=_blank>Schemathesis</a> na testovanie API s pomocou API schémy (viď aj <a href=https://monikajassova.github.io/blog/netradicne-testovanie/#schema-based-contract-testing>Schema-based contract testing</a>).<h1 id=model-based-testing><a aria-label="Anchor link for: model-based-testing" class=zola-anchor href=#model-based-testing>Model-based testing</a></h1><p>Podstatou MBT je automatické generovanie testov a ich exekúcia na základe modelu systému. Abstraktný model reprezentujúci očakávané správanie, vstupy, výstupy a stavy testovaného systému musí vytvoriť tester. To si opäť vyžaduje prepnúť spôsob myslenia, akým uvažujeme. Model môže byť v podobe diagramu prechodu stavov, konečného automatu, rozhodovacej tabuľky, UML diagramu. MBT sa dá použiť na rôznych úrovniach od unit po systémové a akceptačné testy.<br> Má byť ideálny do agilného prostredia, kde sa menia požiadavky a treba testovať rýchlo a kontinuálne (našla som aj opačnú skúsenosť, že zmeny požiadaviek si vyžiadali aj úplne prerobiť model).<p>Plusy: šetrí čas automatizovaním vytvárania a exekuovania testov, údržba je takisto zjednodušená - len úprava modelu, zvýšené pokrytie, škálovateľnosť - efektívny pre veľké a komplexné systémy<br> Mínusy: strmá krivka učenia, tvorba presných a detailných modelov komplexných systémov je zložitá a časovo náročná, málo využívaný v testerskej komunite - ťažké nájsť nejaké odporúčania a overené postupy<p>Nástroje:<ul><li><a rel="noopener external" class=external href=https://github.com/statelyai/xstate target=_blank>XState</a>, k testovaniu <a rel="noopener external" class=external href=https://stately.ai/docs/generate-test-paths target=_blank>tu</a> a <a rel="noopener external" class=external href=https://css-tricks.com/model-based-testing-in-react-with-state-machines/ target=_blank>článok o prepojení XState a testovacích frameworkov Jest a Puppeteer</a><li><a rel="noopener external" class=external href=https://graphwalker.github.io/ target=_blank>GraphWalker</a><li><a rel="noopener external" class=external href=https://github.com/intel/fMBT target=_blank>fMBT</a></ul><p>Teória vyzerá pekne, ale zatiaľ som nevidela úspešný príklad z reálnej praxe na nejakom komplexnom projekte. My sme MBT skúšali ako proof of concept testovania decentralizovanej aplikácie DAO s využitím XState. S návrhom ideálneho modelu sme mali ťažkosti (bol to pokus-omyl) a prístup sme si nezvolili, ale vytvorený stavový diagram slúžil ako dobrá vizuálna dokumentácia a oceňovali sme, že prístup nás nútil zamyslieť sa nad rôznymi stavmi, do ktorých sa aplikácia môže dostať.</p><img alt="Xstate model ₋ voter" aspect-ratio="1652 / 1652" decoding=async loading=lazy src=https://monikajassova.github.io/processed_images/xstate-model-voter.70ce028c0e3874ac.avif><h1 id=contract-testing-code-based><a aria-label="Anchor link for: contract-testing-code-based" class=zola-anchor href=#contract-testing-code-based>Contract testing (code-based)</a></h1><p>Contract testy sa nachádzajú v testovacej pyramíde medzi unit a integračnými testami. Ich úlohou je zaistiť, že dvojica komponentov vie stále komunikovať cez API napriek zmenám v kóde (teda bol dodržaný skôr dohodnutý kontrakt o vzájomnej komunikácii). Ich podstatou je, že sú asynchrónne a bežia v izolácii - nevyžadujú si prostredie, na ktorom by oba komponenty museli bežať súčasne. Na problémy sa dá prísť ešte pred nasadením na testovacie prostredie, v rámci CI checku na pull requeste v repozitári. Ideálne pre microservices architektúru. Netestujú, či funkcionalita za nejakým API volaním funguje, to stále potrebujeme mať podchytené v iných funkcionálnych testoch.<p>Plusy: exekuuje reálny aplikačný kód na oboch stranách interakcie, testuje aj statusové kódy a základné predpoklady o odpovedi, zároveň príklady slúžia ako špecifikácia a dokumentácia, silné verifikačné záruky, časť testov na vyšších úrovniach môže byť presunutá do contract testov<br> Mínusy: zložitejší a časovo náročnejší na začiatok, potrebná údržba testov<p>Typy:<ol><li><p>consumer-driven: kontrakt definuje konzument API (klient) na základe toho, čo očakáva od producenta API (servera). Pokrýva len časť, ktorú potrebuje konkrétny konzument (producent môže mať ďalších konzumentov, ktorí majú iné požiadavky). Akékoľvek správanie producenta, ktoré nie je využívané konzumentami sa môže meniť bez obavy z porušenia kontraktu a padnutia testov. Špecifikácia je nahratá s pomocou mocku producenta. Interakcie (vstupy a očakávané výstupy) sú zachytené v súbore kontraktu. Ten sa zdieľa s producentom, ktorý kontrakt verifikuje na svojej strane - prehratím interakcie a porovnaním s očakávanymi odpoveďami.</p><li><p>producer-driven: kontrakt definuje producent API (ako súbor všetkého, čo poskytuje) a konzumenti ho používajú na uistenie, že vedia spracovať uvedené odpovede úspešne. Chýba spätná väzba.</p><li><p>bidirectional: producent aj konzument vytvoria svoju verziu kontraktu pre špecifickú integráciu - očakávania o správaní producenta a špecifikáciu správania producenta. Porovnanie a verifikáciu kontraktu robí nezávislá tretia strana, ktorej poskytnú kontrakty. Konzument aj producent sa vedia dotazovať na výsledky verifikácie, aby zistili, či nastali nejaké integračné problémy a či je bezpečné nové verzie nasadiť na prostredie.</p></ol><p>Viac informácií má na svojej stránke Bas Dijkstra, ktorý sa na contract testing špecializuje:<ul><li><a rel="noopener external" class=external href=https://www.ontestautomation.com/an-introduction-to-contract-testing-part-1-meet-the-players/ target=_blank>https://www.ontestautomation.com/an-introduction-to-contract-testing-part-1-meet-the-players/</a><li><a rel="noopener external" class=external href=https://www.ontestautomation.com/contract-testing-what-not-to-test-for-part-1/ target=_blank>https://www.ontestautomation.com/contract-testing-what-not-to-test-for-part-1/</a></ul><p>alebo ich nájdete v nedávno vydanej knihe <a rel="noopener external" class=external href=https://www.manning.com/books/contract-testing-in-action target=_blank>Contract Testing in Action</a>.<p>Frameworky:<ul><li><a rel="noopener external" class=external href=https://pact.io/ target=_blank>Pact</a> s podporou JS, JVM, Rust, Python, Go, PHP, .NET<li><a rel="noopener external" class=external href=https://github.com/karatelabs/karate/tree/master/karate-netty#consumer-provider-example target=_blank>Karate</a> - kontrakty definované vo formáte Gherkin, jar na beh testov<li><a rel="noopener external" class=external href=https://spring.io/projects/spring-cloud-contract target=_blank>Spring Cloud Contract</a> - podporuje definovanie kontraktov v YAML a Groovy a ich beh v Dockeri<li><a rel="noopener external" class=external href=https://specmatic.io/ target=_blank>Specmatic</a> - no-code riešenie, ktoré generuje contract testy z API špecifikácií</ul><p>Bohužiaľ, k implementácii contract testingu sme sa na projekte z časových dôvodov a iných priorít nedostali, ale videli sme prípady, kedy by tento prístup pomohol v skorom zachytení nežiaducich zmien priamo u komponentu, ktorý ich spôsobil.<h2 id=schema-based-contract-testing><a aria-label="Anchor link for: schema-based-contract-testing" class=zola-anchor href=#schema-based-contract-testing>Schema-based contract testing</a></h2><p>Schéma alebo špecifikácia API je statický formálny popis API, ktorý zachytáva všetky možné koncové body, požiadavky a odpovede. Príklady schém pre rôzne protokoly sú <a rel="noopener external" class=external href=https://swagger.io/resources/open-api/ target=_blank>OpenAPI Specification</a> pre REST, <a rel="noopener external" class=external href=https://graphql.org/learn/schema/ target=_blank>GraphQL schema</a>, <a rel="noopener external" class=external href=https://www.asyncapi.com/en target=_blank>AsyncAPI</a>, <a rel="noopener external" class=external href=https://json-schema.org/ target=_blank>JSON schema</a> alebo <a rel="noopener external" class=external href=https://open-rpc.org/ target=_blank>OpenRPC</a>.<p>SBCT kontroluje, či konzument používa správy, ktoré sa zhodujú s (podmnožinou) danej API schémy a či producent produkuje výstup, ktorý súhlasí s touto schémou. Tvrdí, že daná strana komunikácie je kompatibilná so schémou v určitom čase.<br> Stále je však potrebné sledovať, aké verzie aplikácií sú nasadené, aby sme sa uistili, že obe strany používajú kompatibilné verzie schémy. Správa tiež môže byť kompatibilná so schémou (syntakticky správna), ale nemať význam a byť nesprávna.<p>Plusy: ľahšie a rýchlejšie je s nimi začať, menšia údržba - ak sú schémy generované priamo z kódu, zároveň slúži ako dokumentácia API, odstraňuje nutnosť existencie testovacích dát<br> Mínusy: robí porovnanie schém - teda tvaru dát, ostatné aspekty kontraktu (cesty, metódy, hlavičky, statusové kódy, špecifické množiny vstupov) nie sú testované, nižšie verifikačné záruky, schéma je často ručne vytvorená a udržiavaná - môže nastať odchýlka medzi schémou a reálnym kódom.<p>Viac v seriáli na <a rel="noopener external" class=external href=https://pactflow.io/blog/contract-testing-using-json-schemas-and-open-api-part-1/ target=_blank>https://pactflow.io/blog/contract-testing-using-json-schemas-and-open-api-part-1/</a><p>Pár nástrojov:<ul><li><a rel="noopener external" class=external href=https://stoplight.io/open-source/prism target=_blank>Prism</a> pre OpenAPI špecifikácie<li><a rel="noopener external" class=external href=https://microcks.io/ target=_blank>Microcks</a> testuje nasadené implementácie oproti API špecifikácii<li><a rel="noopener external" class=external href=https://schemathesis.io/ target=_blank>Schemathesis</a> PBT framework na API testovanie, deteguje aj odchýlku medzi implementáciou API a OpenAPI alebo GraphQL špecifikáciou<li><a rel="noopener external" class=external href=https://github.com/apiaryio/dredd target=_blank>Dredd</a> už archivovaný projekt, ktorý testoval, či implementácia backendu zodpovedá API schéme</ul><h1 id=trace-based-testing><a aria-label="Anchor link for: trace-based-testing" class=zola-anchor href=#trace-based-testing>Trace-based testing</a></h1><p>Na integrovanom prostredí vrátane produkcie (ak máme naprieč komponentami systému implementovaný tracing) môžeme okrem pasívneho monitoringu zbierané dáta využiť aj na proaktívny testovací účel. TBT overuje tvrdenia o trase stôp pre danú transakciu a umožňuje integračné aj komplexné E2E testy. Definujeme model, nasleduje zber dát a na záver vyhodnotenie, či dáta zodpovedajú modelu. Rovnaký model a test môže byť použitý pri integračných testoch na lokálnom prostredí aj unit testoch s mockmi. Sú vhodné najmä pre microservices architektúru a distribuované systémy. TBT sa dajú kombinovať aj so záťažovými testami a pomôcť pri odhalení úzkych hrdiel v systéme.<br> Tvorbou testov nad traceami zároveň robíme tracing dôležitou súčasťou vývoja, nie dodatočnou myšlienkou a vytvárame cyklus spätnej väzby, ktorý má za následok lepšie testovanie aj lepšiu observabilitu = pozorovateľnosť (dá sa nazvať aj trace-driven development) a tým pádom aj rýchlejšie určenie príčiny v prípade problémov. Akékoľvek nástroje, ktoré umožňujú analýzu štruktúrovaných dát nám pomôžu pri TBT. Ďalšie nadstavby môžu byť kombinácie s temporálnou logikou, model checkermi a formálnou verifikáciou.<p>Príkladom je <a rel="noopener external" class=external href=https://tracetest.io/ target=_blank>Tracetest</a> pre OpenTelemetry. Poskytuje mnoho integrácií vrátane Playwrightu, čím umožňuje naozajstné E2E testovanie, kedy sa test začne na UI webstránky a dostane schopnosť vidieť a sledovať celé interné spracovanie danej požiadavky skrz back end, databázu a externé služby.<div><iframe allowfullscreen height=315 mozallowfullscreen src=https://www.youtube.com/embed/MP_edlFWRi4 webkitallowfullscreen width=100%></iframe></div><h1 id=chaos-engineering><a aria-label="Anchor link for: chaos-engineering" class=zola-anchor href=#chaos-engineering>Chaos engineering</a></h1><p>Zaujímavým prístupom sú nefunkcionálne testovacie techniky na hodnotenie toho, ako je systém robustný, odolný voči nepriaznivým vplyvom a abnormálnemu správaniu, ako toleruje chyby a schopnosť zotaviť sa z nich.<br> Chaos engineering je praktika úmyselného zavádzania chýb a zlyhaní na rôznych úrovniach (odstránenie Kubernetes podu, zvýšenie latencie, úplné prerušenie sieťového spojenia medzi komponentami, simulácia používateľských chýb atď.). Cieľom je potvrdiť alebo vyvrátiť naše hypotézy o tom, ako systém zareaguje a či sa zotaví a zlepšiť celkovú odolnosť systému odhalením skrytých slabín a validáciou mechanizmov obnovy za realistickej pracovnej záťaže a kombinácie závad. Zameriava sa teda na zvýšenie dôvery v schopnosť distribuovaných systémov čeliť turbulentným podmienkam skutočného sveta vrátane nepredvídateľných zlyhaní.<br> Vykonáva sa na prostrediach podobných produkcii aj priamo na produkcii.<br> Podmienkou je mať systém dostatočne zrelý, spoľahlivý (aby nepadal aj bez pričinenia chaos engineeringu) a tiež observabilita na dostatočnej úrovni, aby sme do systému "videli", ako sa správa a mohli sledovať hodnoty kľúčových indikátorov.<p>Pár nástrojov:<ul><li><a rel="noopener external" class=external href=https://chaos-mesh.org/ target=_blank>Chaos Mesh</a> a <a rel="noopener external" class=external href=https://litmuschaos.io/ target=_blank>Litmus</a> pre Kubernetes<li><a rel="noopener external" class=external href=https://github.com/netflix/chaosmonkey target=_blank>Chaos Monkey</a> od Netflixu, ktorý bol priekopníkom chaos engineeringu<li><a rel="noopener external" class=external href=https://chaostoolkit.org/ target=_blank>ChaosToolkit</a><li>viac na <a rel="noopener external" class=external href=https://github.com/dastergon/awesome-chaos-engineering target=_blank>https://github.com/dastergon/awesome-chaos-engineering</a></ul><p>Chaos engineering spadá pod resilience testing (testovanie odolnosti) spolu s:<ul><li>fault injection: úmyselne zavádza špecifické závady a zlyhania do systému na validáciu jeho robustnosti a schopnosti poradiť si s chybami. Používa sa skoro vo vývojovom cykle v kontrolovanom testovacom prostredí na potvrdenie, že systém sa správa správne za známych chybových podmienok.<li>stress testing: vystavuje systém extrémnej pracovnej záťaži alebo vyťaženiu zdrojov (CPU, pamäť...) a má za cieľ identifikovať výkonnostné úzke hrdlá, zlyhania z preťaženia<li>failover testing: úmyselne spôsobí vypovedanie služby a pozoruje, či systém dokáže prejsť na zálohu alebo rezervnú službu<li>data recovery testing: verifikuje, že dáta sa dajú obnoviť zo záloh a že zálohovacie mechanizmy sú efektívne a proces obnovy spoľahlivý a výkonný. Mal by byť vykonávaný periodicky, hodí sa tiež po veľkých zmenách v dátach a migráciách.<li>disaster recovery testing: pomáha uistiť sa, že systém môže byť obnovený a spojazdnený po udalostiach veľkého rozsahu ako výpadku dátových centier. Zahŕňa aktivity ako obnovu zo záloh, prepnutie na redundantné systémy alebo presmerovanie prevádzky na disaster recovery prostredie. Vhodný po signifikantných zmenách v infraštruktúre.</ul><p><em>Ako vidíte, je toho neúrekom a v testovaní sa stále dá vymyslieť a nájsť niečo nové, kombinovať rôzne prístupy. A v súčasnosti aj využívať pomoc AI.</em></section></article></main></div><div class=giscus></div><script async crossorigin issue-term=pathname repo=MonikaJassova/monikajassova.github.io src=https://utteranc.es/client.js theme=github-dark></script><footer class=footer>© Monika Jaššová, 2022 - 2026</footer></div><div class=right-content><div class=toc><div class=heading>Obsah</div><ul class=toc-list><li class=parent><a href=https://monikajassova.github.io/blog/netradicne-testovanie/#mutation-testing>Mutation testing</a><li class=parent><a href=https://monikajassova.github.io/blog/netradicne-testovanie/#property-based-testing>Property-based testing</a><li class=parent><a href=https://monikajassova.github.io/blog/netradicne-testovanie/#model-based-testing>Model-based testing</a><li class=parent><a href=https://monikajassova.github.io/blog/netradicne-testovanie/#contract-testing-code-based>Contract testing (code-based)</a> <ul><li><a href=https://monikajassova.github.io/blog/netradicne-testovanie/#schema-based-contract-testing>Schema-based contract testing</a></ul><li class=parent><a href=https://monikajassova.github.io/blog/netradicne-testovanie/#trace-based-testing>Trace-based testing</a><li class=parent><a href=https://monikajassova.github.io/blog/netradicne-testovanie/#chaos-engineering>Chaos engineering</a></ul></div></div>